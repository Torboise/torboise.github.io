<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense Screensaver</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            background-color: black;
        }
        .instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Make canvas fullscreen
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game constants - now using dynamic screen size
        let SCREEN_WIDTH = canvas.width;
        let SCREEN_HEIGHT = canvas.height;
        const TOWER_RADIUS = 20;
        const ENEMY_RADIUS = 5;
        const BULLET_RADIUS = 3;
        const SPAWN_RADIUS = Math.min(SCREEN_WIDTH, SCREEN_HEIGHT) * 0.4; // Proportional to screen
        const ENEMY_SPEED = 1;

        // Colors
        const BLACK = '#000000';
        const WHITE = '#FFFFFF';
        const RED = '#FF0000';
        const GREEN = '#00FF00';

        class Tower {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = TOWER_RADIUS;
                this.attack_power = 2;
                this.attack_speed = 1.5;
                this.attack_range = 100;
                this.displayRange = 100; // For smooth animation
                this.max_health = 10;
                this.health = 10;
                this.health_regen = 0.1;
                this.last_shot_time = Date.now();
                this.last_regen_time = Date.now();
                this.borderModeWave = -1; // Track which wave border mode started
                this.borderAlpha = 1.0; // Alpha for fading border
                this.lastRingFireTime = Date.now(); // Timer for ring fire when maxed
                this.ringDensity = 4; // Number of bullets in ring (default 4)
                this.ringSpeed = 10.0; // Ring fire interval in seconds (default 10)
                this.speedBoostMultiplier = 1.0; // Speed boost multiplier (starts at 1.0, increases by 0.5 each cycle)
            }

            canShoot() {
                const currentTime = Date.now();
                return currentTime - this.last_shot_time >= (1000 / this.attack_speed);
            }

            updateHealth() {
                const currentTime = Date.now();
                const deltaTime = currentTime - this.last_regen_time;
                
                // Update health smoothly based on time elapsed (regen per millisecond)
                if (deltaTime > 0) {
                    const regenAmount = this.health_regen * (deltaTime / 1000); // Convert to per-millisecond
                    this.health = Math.min(this.max_health, this.health + regenAmount);
                    this.last_regen_time = currentTime;
                }
                
                // Smooth tween for range display
                const rangeDiff = this.attack_range - this.displayRange;
                if (Math.abs(rangeDiff) > 0.5) {
                    this.displayRange += rangeDiff * 0.1; // Smooth animation
                } else {
                    this.displayRange = this.attack_range; // Snap to final value
                }
            }

            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }

            shoot(targetEnemy) {
                let bullets = [];
                
                // Regular shooting
                if (this.canShoot() && targetEnemy) {
                    const dx = targetEnemy.x - this.x;
                    const dy = targetEnemy.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= this.attack_range && distance > 0) {
                        this.last_shot_time = Date.now();
                        const normalizedDx = dx / distance;
                        const normalizedDy = dy / distance;
                        bullets.push(new Bullet(this.x, this.y, normalizedDx, normalizedDy, this.attack_power));
                    }
                }
                
                // Ring fire when attack speed is maxed (200)
                if (this.attack_speed >= 200) {
                    const currentTime = Date.now();
                    const ringInterval = this.ringSpeed * 1000; // Convert to milliseconds
                    if (currentTime - this.lastRingFireTime >= ringInterval) {
                        this.lastRingFireTime = currentTime;
                        
                        // Create ring of bullets based on density
                        const bulletCount = Math.floor(this.ringDensity);
                        const angleStep = 360 / bulletCount;
                        for (let i = 0; i < bulletCount; i++) {
                            const angle = i * angleStep;
                            const radians = (angle * Math.PI) / 180;
                            const dx = Math.cos(radians);
                            const dy = Math.sin(radians);
                            bullets.push(new Bullet(this.x, this.y, dx, dy, this.attack_power));
                        }
                    }
                }
                
                return bullets;
            }

            draw(ctx, game) {
                // Draw attack range (using animated displayRange)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.displayRange, 0, 2 * Math.PI);
                ctx.strokeStyle = WHITE;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw wrapping lines when circle breaches screen edges
                const radius = this.displayRange;
                
                // Check if circle completely encompasses the screen
                const maxDistanceToCorner = Math.max(
                    Math.sqrt(this.x * this.x + this.y * this.y), // Top-left corner
                    Math.sqrt((SCREEN_WIDTH - this.x) * (SCREEN_WIDTH - this.x) + this.y * this.y), // Top-right corner
                    Math.sqrt(this.x * this.x + (SCREEN_HEIGHT - this.y) * (SCREEN_HEIGHT - this.y)), // Bottom-left corner
                    Math.sqrt((SCREEN_WIDTH - this.x) * (SCREEN_WIDTH - this.x) + (SCREEN_HEIGHT - this.y) * (SCREEN_HEIGHT - this.y)) // Bottom-right corner
                );
                
                if (radius >= maxDistanceToCorner) {
                    // Track when border mode starts
                    if (this.borderModeWave === -1) {
                        this.borderModeWave = game.currentWave; // Need to pass game context
                        this.borderAlpha = 1.0;
                    }
                    
                    // Fade out if we're past the wave where border mode started
                    if (game.currentWave > this.borderModeWave) {
                        this.borderAlpha = Math.max(0, this.borderAlpha - 0.02); // Fade out gradually
                    }
                    
                    // Only draw if alpha > 0
                    if (this.borderAlpha > 0) {
                        // Circle completely encompasses screen - draw lines on all four edges
                        ctx.strokeStyle = `rgba(255, 255, 255, ${this.borderAlpha})`;
                        ctx.lineWidth = 1;
                        
                        // Left edge
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, SCREEN_HEIGHT);
                        ctx.stroke();
                        
                        // Right edge
                        ctx.beginPath();
                        ctx.moveTo(SCREEN_WIDTH, 0);
                        ctx.lineTo(SCREEN_WIDTH, SCREEN_HEIGHT);
                        ctx.stroke();
                        
                        // Top edge
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(SCREEN_WIDTH, 0);
                        ctx.stroke();
                        
                        // Bottom edge
                        ctx.beginPath();
                        ctx.moveTo(0, SCREEN_HEIGHT);
                        ctx.lineTo(SCREEN_WIDTH, SCREEN_HEIGHT);
                        ctx.stroke();
                    }
                } else {
                    // Reset border mode when circle shrinks back
                    this.borderModeWave = -1;
                    this.borderAlpha = 1.0;
                    // Circle partially extends beyond screen - draw intersection lines
                    // Left edge
                    if (this.x - radius < 0) {
                        const intersectY1 = this.y - Math.sqrt(radius * radius - this.x * this.x);
                        const intersectY2 = this.y + Math.sqrt(radius * radius - this.x * this.x);
                        if (intersectY1 >= 0 && intersectY1 <= SCREEN_HEIGHT && intersectY2 >= 0 && intersectY2 <= SCREEN_HEIGHT) {
                            ctx.beginPath();
                            ctx.moveTo(0, intersectY1);
                            ctx.lineTo(0, intersectY2);
                            ctx.strokeStyle = WHITE;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    }
                    
                    // Right edge
                    if (this.x + radius > SCREEN_WIDTH) {
                        const dx = SCREEN_WIDTH - this.x;
                        if (dx * dx < radius * radius) {
                            const intersectY1 = this.y - Math.sqrt(radius * radius - dx * dx);
                            const intersectY2 = this.y + Math.sqrt(radius * radius - dx * dx);
                            if (intersectY1 >= 0 && intersectY1 <= SCREEN_HEIGHT && intersectY2 >= 0 && intersectY2 <= SCREEN_HEIGHT) {
                                ctx.beginPath();
                                ctx.moveTo(SCREEN_WIDTH, intersectY1);
                                ctx.lineTo(SCREEN_WIDTH, intersectY2);
                                ctx.strokeStyle = WHITE;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                    }
                    
                    // Top edge
                    if (this.y - radius < 0) {
                        const intersectX1 = this.x - Math.sqrt(radius * radius - this.y * this.y);
                        const intersectX2 = this.x + Math.sqrt(radius * radius - this.y * this.y);
                        if (intersectX1 >= 0 && intersectX1 <= SCREEN_WIDTH && intersectX2 >= 0 && intersectX2 <= SCREEN_WIDTH) {
                            ctx.beginPath();
                            ctx.moveTo(intersectX1, 0);
                            ctx.lineTo(intersectX2, 0);
                            ctx.strokeStyle = WHITE;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    }
                    
                    // Bottom edge
                    if (this.y + radius > SCREEN_HEIGHT) {
                        const dy = SCREEN_HEIGHT - this.y;
                        if (dy * dy < radius * radius) {
                            const intersectX1 = this.x - Math.sqrt(radius * radius - dy * dy);
                            const intersectX2 = this.x + Math.sqrt(radius * radius - dy * dy);
                            if (intersectX1 >= 0 && intersectX1 <= SCREEN_WIDTH && intersectX2 >= 0 && intersectX2 <= SCREEN_WIDTH) {
                                ctx.beginPath();
                                ctx.moveTo(intersectX1, SCREEN_HEIGHT);
                                ctx.lineTo(intersectX2, SCREEN_HEIGHT);
                                ctx.strokeStyle = WHITE;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                    }
                }

                // Draw tower
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fillStyle = WHITE;
                ctx.fill();

                // Draw health bar
                const barWidth = 60;
                const barHeight = 8;
                const barX = this.x - barWidth / 2;
                const barY = this.y - this.radius - 15;

                // Background
                ctx.fillStyle = RED;
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // Current health
                const healthRatio = this.health / this.max_health;
                ctx.fillStyle = GREEN;
                ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
            }
        }

        class Enemy {
            constructor(x, y, enemyType = 1, wave = 1, towerAttackPower = 2) {
                this.x = x;
                this.y = y;
                this.type = enemyType;

                const waveHealthMultiplier = 1 + (wave - 1) * 0.15;
                const waveDamageMultiplier = 1 + (wave - 1) * 0.1;

                if (enemyType === 1) {
                    this.radius = ENEMY_RADIUS;
                    this.health = Math.floor(1 * waveHealthMultiplier);
                    this.speed = ENEMY_SPEED;
                    this.damage = Math.floor(1 * waveDamageMultiplier);
                } else if (enemyType === 2) {
                    this.radius = ENEMY_RADIUS + 3;
                    this.health = Math.floor(5 * waveHealthMultiplier);
                    this.speed = ENEMY_SPEED * 0.8;
                    this.damage = Math.floor(4 * waveDamageMultiplier);
                } else if (enemyType === 3) {
                    this.radius = ENEMY_RADIUS + 6;
                    this.health = Math.floor(12 * waveHealthMultiplier);
                    this.speed = ENEMY_SPEED * 0.6;
                    this.damage = Math.floor(8 * waveDamageMultiplier);
                } else if (enemyType === 4) {
                    this.radius = ENEMY_RADIUS + 10;
                    this.health = Math.floor(25 * waveHealthMultiplier);
                    this.speed = ENEMY_SPEED * 0.4;
                    this.damage = Math.floor(15 * waveDamageMultiplier);
                } else if (enemyType === 5) {
                    // Boss enemy - appears every 10+ waves
                    this.radius = ENEMY_RADIUS + 20; // Much larger
                    this.health = Math.floor(100 * waveHealthMultiplier);
                    this.speed = ENEMY_SPEED * 0.3; // Slow but tanky
                    this.damage = Math.floor(30 * waveDamageMultiplier);
                } else if (enemyType === 6) {
                    // Super boss - appears only once every 10 waves
                    this.radius = ENEMY_RADIUS + 30; // Enormous
                    this.health = Math.floor(towerAttackPower * 20 * 33); // Health scales with tower power (33x - 2/3 of previous)
                    this.speed = ENEMY_SPEED * 0.2; // Very slow
                    this.damage = Math.floor(50 * waveDamageMultiplier);
                } else if (enemyType === 7) {
                    // Brute enemy - appears after wave 25, uncommon
                    this.radius = ENEMY_RADIUS + 12; // Larger than type 4
                    this.health = Math.floor(towerAttackPower * 10); // Health = tower power * 10
                    this.speed = ENEMY_SPEED * 0.5; // Moderate speed
                    this.damage = Math.floor(20 * waveDamageMultiplier);
                }
                
                // Store max health for healthbar calculations
                this.maxHealth = this.health;
                
                // Track last attack time for boss attack cooldown (only for type 6)
                this.lastAttackTime = 0;
            }

            update(towerX, towerY, speedMultiplier = 1.0) {
                const dx = towerX - this.x;
                const dy = towerY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) {
                    this.x += (dx / distance) * this.speed * speedMultiplier;
                    this.y += (dy / distance) * this.speed * speedMultiplier;
                }
            }

            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }

            draw(ctx) {
                // Calculate dynamic radius for brutes and bosses based on health
                let currentRadius = this.radius;
                if (this.type === 5 || this.type === 6 || this.type === 7) {
                    const healthPercent = this.health / this.maxHealth;
                    const minScale = 0.3; // Minimum 30% of original size
                    const scale = minScale + (1 - minScale) * healthPercent;
                    currentRadius = this.radius * scale;
                }
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius, 0, 2 * Math.PI);
                
                // Set color based on enemy type
                if (this.type === 7) {
                    ctx.fillStyle = '#FFFF00'; // Yellow for brutes
                } else if (this.type === 5 || this.type === 6) {
                    ctx.fillStyle = '#FF00FF'; // Magenta for bosses
                } else {
                    ctx.fillStyle = RED; // Red for regular enemies
                }
                ctx.fill();
                
                // Draw healthbar for bosses and brutes (types 5, 6, and 7)
                if (this.type === 5 || this.type === 6 || this.type === 7) {
                    const barWidth = currentRadius * 2;
                    const barHeight = 8;
                    const barX = this.x - barWidth / 2;
                    const barY = this.y - currentRadius - barHeight - 5;
                    
                    // Background bar
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Health bar
                    const healthPercent = this.health / this.maxHealth;
                    const healthWidth = barWidth * healthPercent;
                    ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
                    ctx.fillRect(barX, barY, healthWidth, barHeight);
                    
                    // Border
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                    
                    // Health text (only for bosses, not brutes)
                    if (this.type === 5 || this.type === 6) {
                        ctx.fillStyle = 'white';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        const healthText = `${Math.ceil(this.health)}/${Math.ceil(this.maxHealth)}`;
                        ctx.fillText(healthText, this.x, barY - 2);
                    }
                }
            }
        }

        class Bullet {
            constructor(x, y, dx, dy, damage) {
                this.x = x;
                this.y = y;
                this.dx = dx * 5;
                this.dy = dy * 5;
                this.radius = BULLET_RADIUS;
                this.damage = damage;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
            }

            isOffScreen() {
                return (this.x < 0 || this.x > SCREEN_WIDTH || 
                        this.y < 0 || this.y > SCREEN_HEIGHT);
            }

            collidesWith(enemy) {
                const dx = this.x - enemy.x;
                const dy = this.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.radius + enemy.radius);
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fillStyle = WHITE;
                ctx.fill();
            }
        }

        class ExplosionParticle {
            constructor(x, y, isBossExplosion = false) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * 2 * Math.PI;
                const speed = isBossExplosion ? (Math.random() * 3 + 1) : (Math.random() * 6 + 2); // Slower for boss
                this.dx = Math.cos(angle) * speed;
                this.dy = Math.sin(angle) * speed;
                this.life = isBossExplosion ? (Math.random() * 60 + 240) : (Math.random() * 30 + 30); // 4+ seconds for boss
                this.maxLife = this.life;
                this.size = isBossExplosion ? (Math.random() * 8 + 4) : (Math.random() * 4 + 2); // Larger for boss
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.dx *= 0.95;
                this.dy *= 0.95;
                this.life -= 1;
                return this.life > 0;
            }

            draw(ctx) {
                const alphaRatio = this.life / this.maxLife;
                const colorIntensity = Math.floor(255 * alphaRatio);
                
                let color;
                if (alphaRatio > 0.7) {
                    color = `rgb(255, 255, ${colorIntensity})`;
                } else if (alphaRatio > 0.3) {
                    color = `rgb(255, ${colorIntensity}, 0)`;
                } else {
                    color = `rgb(${colorIntensity}, 0, 0)`;
                }

                const currentSize = Math.max(1, this.size * alphaRatio);
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentSize, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
            }
        }

        class Button {
            constructor(x, y, width, height, text, cost) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.text = text;
                this.cost = cost;
            }

            draw(ctx, coins) {
                // Button outline
                ctx.strokeStyle = WHITE;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // Button text
                const color = coins >= this.cost ? WHITE : '#666666';
                ctx.fillStyle = color;
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.text} ($${this.cost})`, this.x + this.width / 2, this.y + this.height / 2 + 5);
            }

            isClicked(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }
        }

        class Game {
            constructor() {
                this.updateScreenSize();
                this.tower = new Tower(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);
                this.enemies = [];
                this.bullets = [];
                this.coins = 0;
                this.enemySpawnTimer = 0;
                this.speedMultiplier = 2.0;
                this.speedToggle = false;
                this.gameOver = false;
                this.killsSinceLastUpgrade = 0;
                this.upgradeThreshold = Math.floor(Math.random() * 4) + 1; // Random number between 1-4
                this.explosionParticles = [];

                // Wave system
                this.currentWave = 1;
                this.enemiesInWave = 10;
                this.enemiesSpawnedThisWave = 0;
                this.enemiesKilledThisWave = 0;
                this.waveStartTime = Date.now();
                this.showWaveText = true;
                this.bossSpawnedThisWave = false;

                // Shop buttons - positioned relative to screen size
                this.attackPowerButton = new Button(10, SCREEN_HEIGHT - 100, 150, 35, "Attack Power", 5);
                this.attackSpeedButton = new Button(170, SCREEN_HEIGHT - 100, 150, 35, "Attack Speed", 3);
                this.attackRangeButton = new Button(330, SCREEN_HEIGHT - 100, 150, 35, "Attack Range", 4);
                this.maxHealthButton = new Button(490, SCREEN_HEIGHT - 100, 150, 35, "Max Health", 8);
                this.healthRegenButton = new Button(10, SCREEN_HEIGHT - 60, 150, 35, "Health Regen", 6);
                this.speedButton = new Button(SCREEN_WIDTH - 120, 10, 100, 30, "Speed: 2x", 0);

                // Super mode toggle button (bottom right)
                this.superMode = false;
                this.superModeButton = new Button(SCREEN_WIDTH - 120, SCREEN_HEIGHT - 120, 100, 30, "Super: OFF", 0);

                // Upgrade costs
                this.attackPowerCost = 5;
                this.attackSpeedCost = 3;
                this.attackRangeCost = 4;
                this.maxHealthCost = 8;
                this.healthRegenCost = 6;

                this.setupEventListeners();
            }

            updateScreenSize() {
                SCREEN_WIDTH = canvas.width;
                SCREEN_HEIGHT = canvas.height;
            }

            setupEventListeners() {
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.handleClick(x, y);
                });

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'r' || e.key === 'R') {
                        if (this.gameOver) {
                            this.restartGame();
                        }
                    }
                });
            }

            autoUpgradeAll() {
                // Upgrade attack power
                this.tower.attack_power += 1;
                this.attackPowerCost = Math.floor(this.attackPowerCost * 1.5);
                this.attackPowerButton.cost = this.attackPowerCost;
                
                // Upgrade attack speed
                if (this.tower.attack_speed < 200) {
                    this.tower.attack_speed += 0.5;
                }
                this.attackSpeedCost = Math.floor(this.attackSpeedCost * 1.3);
                this.attackSpeedButton.cost = this.attackSpeedCost;
                
                // Upgrade attack range
                if (this.tower.attack_range < 1400) {
                    this.tower.attack_range += 10;
                    this.tower.attack_range = Math.min(1400, this.tower.attack_range);
                }
                this.attackRangeCost = Math.floor(this.attackRangeCost * 1.4);
                this.attackRangeButton.cost = this.attackRangeCost;
                
                // Upgrade max health
                this.tower.max_health += 2;
                this.tower.health += 2;
                this.maxHealthCost = Math.floor(this.maxHealthCost * 1.5);
                this.maxHealthButton.cost = this.maxHealthCost;
                
                // Upgrade health regen
                this.tower.health_regen += 0.1;
                this.healthRegenCost = Math.floor(this.healthRegenCost * 1.6);
                this.healthRegenButton.cost = this.healthRegenCost;
                
                // Ring upgrades (only when attack speed is maxed)
                if (this.tower.attack_speed >= 200) {
                    this.tower.ringDensity += 0.05; // Increase density by 0.05
                    this.tower.ringSpeed = Math.max(2.0, this.tower.ringSpeed - 0.002); // Decrease speed by 0.02, min 2.0 seconds
                    
                    // Check if ring speed reached minimum
                    if (this.tower.ringSpeed <= 2.0) {
                        this.tower.speedBoostMultiplier += 0.5; // Increase speed boost by 0.5
                        this.tower.ringSpeed = 10.0; // Reset ring speed to 10 seconds
                    }
                }
            }

            handleClick(x, y) {
                if (this.gameOver) return;

                // Check attack power button
                let cost = this.superMode ? 1 : this.attackPowerCost;
                if (this.attackPowerButton.isClicked(x, y) && this.coins >= cost) {
                    this.coins -= cost;
                    this.tower.attack_power += 1;
                    this.attackPowerCost = Math.floor(this.attackPowerCost * 1.5);
                    this.attackPowerButton.cost = this.attackPowerCost;
                }
                // Check attack speed button
                else if (this.attackSpeedButton.isClicked(x, y) && this.coins >= (this.superMode ? 1 : this.attackSpeedCost) && this.tower.attack_speed < 200) {
                    this.coins -= (this.superMode ? 1 : this.attackSpeedCost);
                    this.tower.attack_speed += 0.5;
                    this.attackSpeedCost = Math.floor(this.attackSpeedCost * 1.3);
                    this.attackSpeedButton.cost = this.attackSpeedCost;
                }
                // Check attack range button
                else if (this.attackRangeButton.isClicked(x, y) && this.coins >= (this.superMode ? 1 : this.attackRangeCost) && this.tower.attack_range < 1400) {
                    this.coins -= (this.superMode ? 1 : this.attackRangeCost);
                    this.tower.attack_range += 20;
                    this.tower.attack_range = Math.min(1400, this.tower.attack_range);
                    this.attackRangeCost = Math.floor(this.attackRangeCost * 1.4);
                    this.attackRangeButton.cost = this.attackRangeCost;
                }
                // Check max health button
                else if (this.maxHealthButton.isClicked(x, y) && this.coins >= (this.superMode ? 1 : this.maxHealthCost)) {
                    this.coins -= (this.superMode ? 1 : this.maxHealthCost);
                    this.tower.max_health += 5;
                    this.tower.health += 5;
                    this.maxHealthCost = Math.floor(this.maxHealthCost * 1.5);
                    this.maxHealthButton.cost = this.maxHealthCost;
                }
                // Check health regen button
                else if (this.healthRegenButton.isClicked(x, y) && this.coins >= (this.superMode ? 1 : this.healthRegenCost)) {
                    this.coins -= (this.superMode ? 1 : this.healthRegenCost);
                    this.tower.health_regen += 0.2;
                    this.healthRegenCost = Math.floor(this.healthRegenCost * 1.6);
                    this.healthRegenButton.cost = this.healthRegenCost;
                }
                // Check speed toggle button
                else if (this.speedButton.isClicked(x, y)) {
                    this.speedToggle = !this.speedToggle;
                    this.speedMultiplier = this.speedToggle ? 4.0 : 2.0;
                    this.speedButton.text = `Speed: ${this.speedToggle ? '4x' : '2x'}`;
                }
                // Check super mode toggle button
                else if (this.superModeButton.isClicked(x, y)) {
                    this.superMode = !this.superMode;
                    this.superModeButton.text = `Super: ${this.superMode ? 'ON' : 'OFF'}`;
                }
            }

            createExplosion(x, y, numParticles = 30, isBossExplosion = false) {
                for (let i = 0; i < numParticles; i++) {
                    this.explosionParticles.push(new ExplosionParticle(x, y, isBossExplosion));
                }
            }

            restartGame() {
                this.updateScreenSize();
                this.tower = new Tower(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);
                this.tower.displayRange = this.tower.attack_range; // Initialize display range
                this.enemies = [];
                this.bullets = [];
                this.coins = 0;
                this.speedMultiplier = 2.0;
                this.speedToggle = false;
                this.gameOver = false;
                this.killsSinceLastUpgrade = 0;
                // Set upgrade threshold based on ring status
                if (this.tower.attack_speed >= 200) {
                    this.upgradeThreshold = Math.floor(Math.random() * 6) + 3; // Random number between 3-8 when rings active
                } else {
                    this.upgradeThreshold = Math.floor(Math.random() * 4) + 1; // Random number between 1-4 normally
                }
                this.explosionParticles = [];
                
                // Reset wave system
                this.currentWave = 1;
                this.enemiesInWave = 10;
                this.enemiesSpawnedThisWave = 0;
                this.enemiesKilledThisWave = 0;
                this.waveStartTime = Date.now();
                this.showWaveText = true;
                this.enemySpawnTimer = 0;
                this.bossSpawnedThisWave = false;
                
                // Reset upgrade costs
                this.attackPowerCost = 5;
                this.attackSpeedCost = 3;
                this.attackRangeCost = 4;
                this.maxHealthCost = 8;
                this.healthRegenCost = 6;
                
                // Update button positions for new screen size
                this.attackPowerButton = new Button(10, SCREEN_HEIGHT - 100, 150, 35, "Attack Power", this.attackPowerCost);
                this.attackSpeedButton = new Button(170, SCREEN_HEIGHT - 100, 150, 35, "Attack Speed", this.attackSpeedCost);
                this.attackRangeButton = new Button(330, SCREEN_HEIGHT - 100, 150, 35, "Attack Range", this.attackRangeCost);
                this.maxHealthButton = new Button(490, SCREEN_HEIGHT - 100, 150, 35, "Max Health", this.maxHealthCost);
                this.healthRegenButton = new Button(10, SCREEN_HEIGHT - 60, 150, 35, "Health Regen", this.healthRegenCost);
                this.speedButton = new Button(SCREEN_WIDTH - 120, 10, 100, 30, "Speed: 2x", 0);
                this.superModeButton = new Button(SCREEN_WIDTH - 120, SCREEN_HEIGHT - 120, 100, 30, "Super: OFF", 0);
                
                this.speedButton.text = "Speed: 2x";
                
                // Reset super mode
                this.superMode = false;
                this.superModeButton.text = "Super: OFF";
            }

            spawnEnemy() {
                const angle = Math.random() * 2 * Math.PI;
                // Spawn enemies just outside the screen
                const spawnDistance = Math.max(SCREEN_WIDTH, SCREEN_HEIGHT) * 0.6 + 50; // Extra 50 pixels outside
                let x = SCREEN_WIDTH / 2 + Math.cos(angle) * spawnDistance;
                let y = SCREEN_HEIGHT / 2 + Math.sin(angle) * spawnDistance;
                
                // Check for special boss on waves divisible by 10 (spawn among first 3 enemies)
                if (this.currentWave % 10 === 0 && !this.bossSpawnedThisWave && this.enemiesSpawnedThisWave < 3) {
                    // Spawn the super boss just off screen with a wider radius
                    const bossSpawnDistance = Math.max(SCREEN_WIDTH, SCREEN_HEIGHT) * 0.55 + 30; // Just off screen with wider radius
                    const bossX = SCREEN_WIDTH / 2 + Math.cos(angle) * bossSpawnDistance;
                    const bossY = SCREEN_HEIGHT / 2 + Math.sin(angle) * bossSpawnDistance;
                    this.enemies.push(new Enemy(bossX, bossY, 6, this.currentWave, this.tower.attack_power));
                    this.bossSpawnedThisWave = true;
                    return;
                }
                
                // Regular enemy spawning logic
                let powerLevel = Math.floor(Math.random() * this.currentWave) + 1;
                
                // Check for brute enemy between waves 5-24 (2% chance)
                if (this.currentWave >= 5 && this.currentWave <= 24 && Math.random() < 0.02) {
                    this.enemies.push(new Enemy(x, y, 7, this.currentWave, this.tower.attack_power)); // Brute enemy
                    return;
                }
                
                // Small chance for large enemies every 10 levels
                const maxLargeLevel = Math.floor(this.currentWave / 10);
                if (maxLargeLevel > 0 && Math.random() < 0.15) { // 15% chance for large enemy
                    const largeEnemyLevel = (Math.floor(Math.random() * maxLargeLevel) + 1) * 10;
                    powerLevel = largeEnemyLevel;
                }
                
                // Map power level to enemy types 1-5
                let enemyType;
                if (powerLevel >= 100) {
                    enemyType = 5; // Boss type
                } else if (powerLevel >= 25) {
                    enemyType = 4;
                } else if (powerLevel >= 12) {
                    enemyType = 3;
                } else if (powerLevel >= 5) {
                    enemyType = 2;
                } else {
                    enemyType = 1;
                }
                
                this.enemies.push(new Enemy(x, y, enemyType, this.currentWave, this.tower.attack_power));
            }

            findNearestEnemy() {
                if (this.enemies.length === 0) return null;
                
                let nearest = null;
                let minDistance = Infinity;
                
                for (const enemy of this.enemies) {
                    const distance = Math.sqrt((enemy.x - this.tower.x) ** 2 + (enemy.y - this.tower.y) ** 2);
                    if (distance <= this.tower.attack_range && distance < minDistance) {
                        minDistance = distance;
                        nearest = enemy;
                    }
                }
                
                return nearest;
            }

            update() {
                if (this.gameOver) {
                    // Update explosion particles
                    for (let i = this.explosionParticles.length - 1; i >= 0; i--) {
                        if (!this.explosionParticles[i].update()) {
                            this.explosionParticles.splice(i, 1);
                        }
                    }
                    return;
                }

                // Update tower health
                this.tower.updateHealth();

                // Spawn enemies
                if (this.enemiesSpawnedThisWave < this.enemiesInWave) {
                    this.enemySpawnTimer++;
                    const currentSpawnRate = Math.max(3, Math.floor(30 / Math.pow(1.15, this.currentWave - 1)));
                    if (this.enemySpawnTimer >= currentSpawnRate) {
                        this.spawnEnemy();
                        this.enemiesSpawnedThisWave++;
                        this.enemySpawnTimer = 0;
                    }
                } else if (this.enemies.length === 0 && this.enemiesSpawnedThisWave >= this.enemiesInWave) {
                    // Wave completion - only when all enemies (including bosses) are dead
                    const bonus = Math.max(5, Math.floor(this.coins * 0.1) + 5);
                    this.coins += bonus;
                    
                    this.currentWave++;
                    this.enemiesInWave = Math.floor(10 * Math.pow(1.3, this.currentWave - 1));
                    this.enemiesSpawnedThisWave = 0;
                    this.enemiesKilledThisWave = 0;
                    this.waveStartTime = Date.now();
                    this.showWaveText = true;
                    this.bossSpawnedThisWave = false; // Reset boss spawn flag
                }

                // Update enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    // Apply speed boost multiplier (increases each time ring reaches 2s)
                    let totalSpeedMultiplier = this.speedMultiplier * this.tower.speedBoostMultiplier;
                    enemy.update(this.tower.x, this.tower.y, totalSpeedMultiplier);
                    
                    // Check collision with tower
                    const distance = Math.sqrt((enemy.x - this.tower.x) ** 2 + (enemy.y - this.tower.y) ** 2);
                    if (distance < this.tower.radius + enemy.radius) {
                        // Boss enemies (type 6) don't end the round when they touch the tower
                        if (enemy.type === 6) {
                            // Boss can only attack once per second
                            const currentTime = Date.now();
                            if (currentTime - enemy.lastAttackTime >= 1000) { // 1000ms = 1 second
                                this.tower.takeDamage(enemy.damage);
                                enemy.lastAttackTime = currentTime;
                                // Don't remove the boss - let it continue attacking
                                if (this.tower.health <= 0) {
                                    this.createExplosion(this.tower.x, this.tower.y, 50);
                                    this.restartGame();
                                    break;
                                }
                            }
                        } else {
                            // Regular enemies are removed on collision
                            this.tower.takeDamage(enemy.damage);
                            this.enemies.splice(i, 1);
                            if (this.tower.health <= 0) {
                                this.createExplosion(this.tower.x, this.tower.y, 50);
                                this.restartGame();
                                break;
                            }
                        }
                    }
                }

                // Tower shooting
                const target = this.findNearestEnemy();
                const bullets = this.tower.shoot(target);
                if (bullets && bullets.length > 0) {
                    for (const bullet of bullets) {
                        this.bullets.push(bullet);
                    }
                }

                // Update bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.update();
                    
                    if (bullet.isOffScreen()) {
                        this.bullets.splice(i, 1);
                        continue;
                    }
                    
                    // Check bullet-enemy collisions
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        if (bullet.collidesWith(enemy)) {
                            if (enemy.takeDamage(bullet.damage)) {
                                // Large explosion for bosses
                                if (enemy.type === 5 || enemy.type === 6) {
                                    this.createExplosion(enemy.x, enemy.y, 50, true); // Boss explosion
                                }
                                
                                this.enemies.splice(j, 1);
                                this.killsSinceLastUpgrade++;
                                this.enemiesKilledThisWave++;
                                // Award coins based on enemy power level
                                this.coins += Math.max(1, Math.floor(enemy.powerLevel * 0.5));
                                
                                // Auto-upgrade with random threshold between 1-4 kills
                                if (this.killsSinceLastUpgrade >= this.upgradeThreshold) {
                                    // Simple explosion effect for upgrade feedback
                                    this.createExplosion(enemy.x, enemy.y, 15);
                                    this.autoUpgradeAll();
                                    this.killsSinceLastUpgrade = 0;
                                    // Set new threshold based on ring status
                                    if (this.tower.attack_speed >= 200) {
                                        this.upgradeThreshold = Math.floor(Math.random() * 6) + 3; // Random number between 3-8 when rings active
                                    } else {
                                        this.upgradeThreshold = Math.floor(Math.random() * 3) + 1; // Random number between 1-4 normally
                                    }
                                }
                            }
                            this.bullets.splice(i, 1);
                            break;
                        }
                    }
                }

                // Update explosion particles
                for (let i = this.explosionParticles.length - 1; i >= 0; i--) {
                    if (!this.explosionParticles[i].update()) {
                        this.explosionParticles.splice(i, 1);
                    }
                }
            }

            draw() {
                // Clear screen
                ctx.fillStyle = BLACK;
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                // Draw tower (only if not game over)
                if (!this.gameOver) {
                    this.tower.draw(ctx, this);
                }

                // Draw enemies
                for (const enemy of this.enemies) {
                    enemy.draw(ctx);
                }

                // Draw bullets
                for (const bullet of this.bullets) {
                    bullet.draw(ctx);
                }

                // Draw explosion particles
                for (const particle of this.explosionParticles) {
                    particle.draw(ctx);
                }

                // Draw UI
                if (this.gameOver) {
                    // Game over screen
                    ctx.fillStyle = WHITE;
                    ctx.font = '48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);
                    
                    ctx.font = '24px Arial';
                    ctx.fillText(`Reached Wave: ${this.currentWave}`, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 60);
                    ctx.fillText('Press R to restart', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 100);
                } else {
                    // Normal game UI
                    ctx.fillStyle = WHITE;
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'left';
                    
                    // Coins (hidden)
                    // ctx.fillText(`Coins: ${this.coins}`, 10, SCREEN_HEIGHT - 140);
                    
                    // Tower stats
                    let statsLine1 = `Power: ${this.tower.attack_power}  Speed: ${this.tower.attack_speed.toFixed(1)}  Range: ${this.tower.attack_range}`;
                    let statsLine2 = `Health: ${this.tower.health.toFixed(1)}/${this.tower.max_health}  Regen: ${this.tower.health_regen.toFixed(1)}/s`;
                    
                    // Add ring stats when speed is maxed
                    if (this.tower.attack_speed >= 200) {
                        statsLine1 += `  Ring: ${Math.floor(this.tower.ringDensity)} @ ${this.tower.ringSpeed.toFixed(2)}s`;
                    }
                    
                    ctx.fillText(statsLine1, 10, 30);
                    ctx.fillText(statsLine2, 10, 60);
                    
                    // Ring timer (top right, only when rings are enabled)
                    if (this.tower.attack_speed >= 200) {
                        const currentTime = Date.now();
                        const timeSinceLastRing = currentTime - this.tower.lastRingFireTime;
                        const ringInterval = this.tower.ringSpeed * 1000;
                        const timeUntilNextRing = Math.max(0, ringInterval - timeSinceLastRing);
                        
                        ctx.textAlign = 'right';
                        ctx.fillText(`Next Ring: ${(timeUntilNextRing / 1000).toFixed(1)}s`, SCREEN_WIDTH - 10, 30);
                        ctx.textAlign = 'left'; // Reset alignment
                    }
                    
                    // Wave info
                    const enemiesRemaining = this.enemiesInWave - this.enemiesKilledThisWave;
                    ctx.fillText(`Wave: ${this.currentWave}  Enemies Left: ${enemiesRemaining}`, 10, 90);
                    
                    // Wave start text
                    if (this.showWaveText) {
                        const elapsed = (Date.now() - this.waveStartTime) / 1000;
                        if (elapsed < 3.0) {
                            const alpha = Math.max(0, 1 - elapsed / 3);
                            ctx.save();
                            ctx.globalAlpha = alpha;
                            ctx.font = '48px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(`WAVE ${this.currentWave}`, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 100);
                            ctx.restore();
                        } else {
                            this.showWaveText = false;
                        }
                    }
                    
                    // Shop buttons (hidden for screensaver)
                    /*
                    // Draw buttons with super mode costs if active
                    if (this.superMode) {
                        // Temporarily set button costs to 1 for display
                        const originalCosts = [
                            this.attackPowerButton.cost, this.attackSpeedButton.cost,
                            this.attackRangeButton.cost, this.maxHealthButton.cost, 
                            this.healthRegenButton.cost
                        ];
                        
                        this.attackPowerButton.cost = 1;
                        this.attackSpeedButton.cost = 1;
                        this.attackRangeButton.cost = 1;
                        this.maxHealthButton.cost = 1;
                        this.healthRegenButton.cost = 1;
                        
                        this.attackPowerButton.draw(ctx, this.coins);
                        this.attackSpeedButton.draw(ctx, this.coins);
                        this.attackRangeButton.draw(ctx, this.coins);
                        this.maxHealthButton.draw(ctx, this.coins);
                        this.healthRegenButton.draw(ctx, this.coins);
                        
                        // Restore original costs
                        this.attackPowerButton.cost = originalCosts[0];
                        this.attackSpeedButton.cost = originalCosts[1];
                        this.attackRangeButton.cost = originalCosts[2];
                        this.maxHealthButton.cost = originalCosts[3];
                        this.healthRegenButton.cost = originalCosts[4];
                    } else {
                        this.attackPowerButton.draw(ctx, this.coins);
                        this.attackSpeedButton.draw(ctx, this.coins);
                        this.attackRangeButton.draw(ctx, this.coins);
                        this.maxHealthButton.draw(ctx, this.coins);
                        this.healthRegenButton.draw(ctx, this.coins);
                    }
                    
                    this.speedButton.draw(ctx, 0);
                    */
                }
                
                // Super mode toggle button (hidden for screensaver)
                // this.superModeButton.draw(ctx, 0);
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (window.game) {
                window.game.updateScreenSize();
                // Reposition tower to center
                window.game.tower.x = SCREEN_WIDTH / 2;
                window.game.tower.y = SCREEN_HEIGHT / 2;
                // Update button positions
                window.game.attackPowerButton = new Button(10, SCREEN_HEIGHT - 100, 150, 35, "Attack Power", window.game.attackPowerButton.cost);
                window.game.attackSpeedButton = new Button(170, SCREEN_HEIGHT - 100, 150, 35, "Attack Speed", window.game.attackSpeedButton.cost);
                window.game.attackRangeButton = new Button(330, SCREEN_HEIGHT - 100, 150, 35, "Attack Range", window.game.attackRangeButton.cost);
                window.game.maxHealthButton = new Button(490, SCREEN_HEIGHT - 100, 150, 35, "Max Health", window.game.maxHealthButton.cost);
                window.game.healthRegenButton = new Button(10, SCREEN_HEIGHT - 60, 150, 35, "Health Regen", window.game.healthRegenButton.cost);
                window.game.speedButton = new Button(SCREEN_WIDTH - 120, 10, 100, 30, window.game.speedButton.text, 0);
                window.game.superModeButton = new Button(SCREEN_WIDTH - 120, SCREEN_HEIGHT - 120, 100, 30, window.game.superModeButton.text, 0);
            }
        });

        // Start the game
        window.game = new Game();
        window.game.gameLoop();
    </script>
</body>
</html>